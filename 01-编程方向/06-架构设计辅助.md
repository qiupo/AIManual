# 架构设计辅助

AI能帮助你进行系统架构设计，从单体应用到微服务，从数据库选型到性能优化。

## 🎯 本章目标

- ✅ 用AI辅助系统设计
- ✅ 技术选型决策
- ✅ 架构模式应用
- ✅ 性能和扩展性设计

## 🏗️ AI辅助架构设计

### 设计流程

```
┌─────────────────────────────────────┐
│  1. 需求分析                        │
│     - 功能需求                      │
│     - 非功能需求                    │
│     - 约束条件                      │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  2. AI初步设计                      │
│     - 架构选项                      │
│     - 技术选型                      │
│     - 权衡分析                      │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  3. 深度设计                        │
│     - 详细架构                      │
│     - 数据设计                      │
│     - 接口设计                      │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  4. 评审和优化                      │
│     - AI评估                        │
│     - 风险分析                      │
│     - 优化建议                      │
└─────────────────────────────────────┘
```

### 实战案例1: Web应用架构

```
提示词：
"设计一个电商网站的架构

需求：
功能需求：
- 商品浏览和搜索
- 购物车和下单
- 支付集成
- 用户系统
- 订单管理
- 后台管理

非功能需求：
- 支持10万日活
- 响应时间 < 200ms
- 99.9%可用性
- 数据不丢失

约束：
- 团队5人
- 预算有限
- 3个月上线

请提供：
1. 整体架构设计
2. 技术栈选型（对比分析）
3. 数据库设计
4. 缓存策略
5. 部署方案
6. 扩展性考虑
7. 风险和应对"
```

**AI架构方案**：

```
# 电商网站架构设计

## 1. 整体架构

采用经典的三层架构 + 微服务准备

```
┌─────────────────────────────────────┐
│  负载均衡 (Nginx/Cloudflare)        │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  Web层 (CDN + 静态资源)             │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  应用层 (API Gateway)               │
│  ┌─────────┬─────────┬─────────┐    │
│  │ 用户    │ 商品    │ 订单    │    │
│  │ 服务    │ 服务    │ 服务    │    │
│  └─────────┴─────────┴─────────┘    │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  数据层                             │
│  ┌─────────┬─────────┬─────────┐    │
│  │ MySQL   │ Redis   │ OSS     │    │
│  │ 主库    │ 缓存    │ 文件    │    │
│  └─────────┴─────────┴─────────┘    │
└─────────────────────────────────────┘
```

## 2. 技术栈选型

### 后端框架对比

| 框架 | 优势 | 劣势 | 适用场景 | 推荐 |
|------|------|------|---------|------|
| Django | 功能完整、安全 | 重量级 | 快速开发 | ⭐⭐⭐⭐⭐ |
| FastAPI | 高性能、现代 | 生态较新 | API服务 | ⭐⭐⭐⭐ |
| Flask | 轻量灵活 | 需要组装 | 小型项目 | ⭐⭐⭐ |
| Node.js | 前后端统一 | 性能一般 | 全栈团队 | ⭐⭐⭐⭐ |

**推荐**：Django + FastAPI混合
- Django：管理后台、复杂业务
- FastAPI：高并发API

### 数据库选型

**主数据库：PostgreSQL**
- 理由：
  - ACID保证
  - 支持复杂查询
  - JSON字段支持
  - 开源免费

**缓存：Redis**
- 理由：
  - 高性能
  - 丰富数据结构
  - 持久化支持

**文件存储：阿里云OSS / AWS S3**
- 理由：
  - 成本低
  - 无限扩展
  - CDN加速

## 3. 数据库设计

### 核心表结构

```sql
-- 用户表
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    phone VARCHAR(20),
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_status ON users(status);

-- 商品表
CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    stock INT DEFAULT 0,
    category_id UUID REFERENCES categories(id),
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_products_category ON products(category_id);
CREATE INDEX idx_products_status ON products(status);
CREATE INDEX idx_products_price ON products(price);

-- 订单表
CREATE TABLE orders (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    order_no VARCHAR(50) UNIQUE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL,
    status VARCHAR(20) DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_orders_user ON orders(user_id);
CREATE INDEX idx_orders_status ON orders(status);
CREATE INDEX idx_orders_created ON orders(created_at);

-- 订单明细表
CREATE TABLE order_items (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE,
    product_id UUID REFERENCES products(id),
    quantity INT NOT NULL,
    price DECIMAL(10, 2) NOT NULL,
    subtotal DECIMAL(10, 2) NOT NULL
);

CREATE INDEX idx_order_items_order ON order_items(order_id);
```

## 4. 缓存策略

### 三级缓存

```python
# L1: 应用内存（本地缓存）
from functools import lru_cache

@lru_cache(maxsize=1000)
def get_product(product_id):
    """热门商品本地缓存"""
    pass

# L2: Redis缓存（分布式）
def get_product_with_cache(product_id):
    """Redis缓存"""
    # 先查Redis
    cached = redis.get(f"product:{product_id}")
    if cached:
        return json.loads(cached)

    # 再查数据库
    product = db.query(Product).get(product_id)
    if product:
        # 写入Redis，1小时过期
        redis.setex(
            f"product:{product_id}",
            3600,
            json.dumps(product)
        )
    return product

# L3: CDN缓存（静态资源）
# 商品图片、静态文件等
```

### 缓存更新策略

```python
def update_product(product_id, data):
    """更新商品，同步更新缓存"""
    # 1. 更新数据库
    product = db.query(Product).get(product_id)
    product.update(data)
    db.commit()

    # 2. 删除Redis缓存
    redis.delete(f"product:{product_id}")

    # 3. 更新本地缓存
    get_product.cache_clear()

    return product
```

## 5. 部署方案

### 开发环境
```yaml
# docker-compose.yml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DEBUG=1
      - DATABASE_URL=postgresql://user:pass@db:5432/db
    depends_on:
      - db
      - redis

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: db
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7
    ports:
      - "6379:6379"

volumes:
  postgres_data:
```

### 生产环境

```
架构：
- 负载均衡：ALB / SLB
- Web服务器：Nginx (2台)
- 应用服务器：Gunicorn (4台)
- 数据库：PostgreSQL主从 (1主2从)
- 缓存：Redis Cluster (3主3从)
- 文件：OSS + CDN

监控：
- 应用监控：Sentry
- 性能监控：Prometheus + Grafana
- 日志：ELK Stack
```

## 6. 扩展性设计

### 水平扩展
```python
# 无状态应用设计
# 所有状态存储在Redis/数据库
# 应用服务器可随意增减

# 数据库分片准备
user_id % 2  # 按用户ID分片
```

### 垂直扩展
```python
# 读写分离
def get_db():
    """读操作：从库"""
    return read_replica_db

def write_db():
    """写操作：主库"""
    return master_db
```

## 7. 性能优化

### 数据库优化
```sql
-- 索引优化
CREATE INDEX CONCURRENTLY idx_orders_composite
ON orders(user_id, status, created_at);

-- 查询优化
EXPLAIN ANALYZE
SELECT * FROM orders
WHERE user_id = ? AND status = 'pending'
ORDER BY created_at DESC
LIMIT 20;
```

### 应用优化
```python
# 批量查询
def get_products(product_ids):
    """批量查询，减少N+1"""
    products = db.query(Product).filter(
        Product.id.in_(product_ids)
    ).all()
    return {p.id: p for p in products}

# 异步处理
from celery import Celery

app = Celery('tasks', broker='redis://localhost')

@app.task
def send_order_email(order_id):
    """异步发送邮件"""
    order = get_order(order_id)
    email_service.send(order.email)
```

## 8. 风险和应对

| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|---------|
| 数据库故障 | 中 | 高 | 主从复制 + 自动故障转移 |
| 缓存雪崩 | 中 | 中 | 缓存预热 + 限流 |
| 订单超卖 | 高 | 高 | Redis库存锁 + 乐观锁 |
| 支付失败 | 中 | 高 | 重试机制 + 异步处理 |
| DDoS攻击 | 低 | 高 | CDN + 限流 + WAF |
```

### 实战案例2: 微服务架构

```
提示词：
"设计一个微服务架构

系统：在线教育平台
功能：
- 用户管理
- 课程管理
- 视频播放
- 在线支付
- 实时聊天
- 作业提交

规模：
- 预计100万用户
- 1万并发

要求：
1. 服务拆分策略
2. 服务间通信
3. 数据管理
4. 服务治理
5. 部署方案"
```

**AI微服务架构**：

```
# 微服务架构设计

## 1. 服务拆分

### 按业务领域拆分

```
┌─────────────────────────────────────────────┐
│           API Gateway (Kong / AWS API)      │
└──────────────┬──────────────────────────────┘
               ↓
    ┌──────────┼──────────┬──────────┐
    ↓          ↓          ↓          ↓
┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐
│用户 │   │课程 │   │订单 │   │消息 │
│服务 │   │服务 │   │服务 │   │服务 │
└─────┘   └─────┘   └─────┘   └─────┘
    ↓          ↓          ↓          ↓
┌─────────────────────────────────────────┐
│  共享服务                               │
│  ┌──────┐  ┌──────┐  ┌──────┐         │
│  │认证  │  │搜索  │  │通知  │         │
│  │服务  │  │服务  │  │服务  │         │
│  └──────┘  └──────┘  └──────┘         │
└─────────────────────────────────────────┘
```

### 服务职责

**用户服务 (User Service)**
- 用户注册登录
- 个人信息管理
- 权限管理
- 数据库：PostgreSQL

**课程服务 (Course Service)**
- 课程CRUD
- 章节管理
- 学习进度
- 数据库：PostgreSQL + MongoDB

**订单服务 (Order Service)**
- 订单创建
- 支付集成
- 退款处理
- 数据库：PostgreSQL

**消息服务 (Message Service)**
- 实时聊天
- 系统通知
- 数据库：MongoDB + Redis

## 2. 服务间通信

### 同步通信：REST / gRPC

```python
# gRPC定义
syntax = "proto3";

service CourseService {
    rpc GetCourse(CourseRequest) returns (CourseResponse);
    rpc ListCourses(ListRequest) returns (ListResponse);
}

# Python实现
class CourseServicer:
    def GetCourse(self, request, context):
        course = db.query(Course).get(request.id)
        return CourseResponse(
            id=course.id,
            name=course.name,
            description=course.description
        )
```

### 异步通信：消息队列

```python
# RabbitMQ / Kafka
import pika

# 订单服务：发送消息
def order_created(order_id):
    connection = pika.BlockingConnection(...)
    channel = connection.channel()

    channel.basic_publish(
        exchange='orders',
        routing_key='created',
        body=json.dumps({'order_id': order_id})
    )

# 消息服务：消费消息
def consume_order_events():
    def callback(ch, method, properties, body):
        event = json.loads(body)
        send_notification(
            user_id=event['user_id'],
            message="订单创建成功"
        )

    channel.basic_consume(
        queue='order_notifications',
        on_message_callback=callback
    )
```

## 3. 数据管理

### 数据库模式
- 每个服务独立数据库
- 避免跨库JOIN
- 通过API获取数据

### 分布式事务
```python
# Saga模式
class OrderSaga:
    def create_order(self, order_data):
        try:
            # 步骤1：创建订单
            order = self.order_service.create(order_data)

            # 步骤2：扣减库存
            inventory = self.inventory_service.decrement(
                order.items
            )

            # 步骤3：创建支付
            payment = self.payment_service.create(
                order.id, order.amount
            )

            return order

        except Exception as e:
            # 补偿事务
            self.order_service.cancel(order.id)
            self.inventory_service.increment(order.items)
            raise
```

## 4. 服务治理

### 服务发现
```yaml
# Consul
services:
  user-service:
    image: user-service:latest
    environment:
      - CONSUL_HOST=consul
    ports:
      - "8001:8001"
```

### 配置中心
```yaml
# Spring Cloud Config / Apollo
user-service:
  database:
    host: localhost
    port: 5432
  redis:
    host: localhost
    port: 6379
```

### 熔断降级
```python
# Hystrix / Resilience4j
from circuitbreaker import circuit

@circuit(failure_threshold=5, recovery_timeout=60)
def get_user(user_id):
    """调用用户服务"""
    return user_service_client.get(user_id)

# 降级处理
@get_user.fallback
def get_user_fallback(user_id):
    """服务失败时返回缓存数据"""
    return cache.get(f"user:{user_id}")
```

### 监控追踪
```python
# 分布式追踪：Jaeger / Zipkin
from opentelemetry import trace

tracer = trace.get_tracer(__name__)

with tracer.start_as_current_span("get_order"):
    order = db.query(Order).get(order_id)
    with tracer.start_as_current_span("get_user"):
        user = user_service.get(order.user_id)
```

## 5. 部署方案

### Kubernetes部署
```yaml
# user-service.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
    spec:
      containers:
      - name: user-service
        image: user-service:1.0
        ports:
        - containerPort: 8001
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: url
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 8001
  type: ClusterIP
```
```

## 💡 架构设计技巧

### 技巧1: 分阶段设计

```
MVP阶段：
- 单体应用
- 简单架构
- 快速上线

成长阶段：
- 服务化
- 读写分离
- 缓存优化

成熟阶段：
- 微服务
- 分布式
- 高可用
```

### 技巧2: 权衡分析

```
提示词：
"对比两种架构方案：

方案A：[描述]
方案B：[描述]

从以下维度对比：
1. 开发难度
2. 运维复杂度
3. 性能
4. 扩展性
5. 成本
6. 团队匹配度

给出推荐和理由"
```

### 技巧3: 渐进式演进

```
单体 → 模块化单体 → 服务化 → 微服务

每一步都验证价值再继续
```

## 小结

- AI是架构设计的得力助手
- 从需求到设计的完整流程
- 权衡各种技术选型
- 考虑扩展性和演进

## 下一步

学习[学习新技术](./07-学习新技术.md)。

---

💡 **架构建议**：没有完美的架构，只有最适合的架构。根据团队、业务、预算选择合适的方案！

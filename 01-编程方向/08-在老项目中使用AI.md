# 在老项目中使用AI

在实际开发中，我们更多时候是在维护和开发已有项目，而不是从零开始。本章专门讲述如何在老项目中有效使用AI，解决复杂历史代码带来的挑战。

## 🎯 本章目标

- ✅ 理解AI在老项目中面临的挑战
- ✅ 掌握让AI快速理解老代码的方法
- ✅ 学会分阶段使用AI的策略
- ✅ 避免常见的坑和误区
- ✅ 建立老项目中AI辅助开发的最佳实践

## 🤔 为什么老项目难用AI？

### 老项目的特点

#### 1. 代码复杂度高
```python
# 老项目常见的情况：复杂的业务逻辑嵌套
def process_order(order):
    # 500行的函数
    # 包含10年前的业务逻辑
    # 经过多手修改，没有清晰的注释
    if order.status == 'pending':
        if order.payment_method == 'credit':
            for item in order.items:
                if item.category == 'electronics':
                    # 特殊处理逻辑1
                    pass
                else:
                    # 特殊处理逻辑2
                    pass
        elif order.payment_method == 'paypal':
            # 另一套复杂逻辑
            pass
    elif order.status == 'shipped':
        # 又是几百行逻辑
        pass
    # ... 继续嵌套
```

#### 2. 缺少文档
- 没有API文档
- 没有架构图
- 注释过时或缺失
- 设计决策没有记录

#### 3. 依赖关系复杂
```
老项目依赖网：
├── legacy-db-wrapper (10年前的库)
├── custom-utils (已离职同事写的工具)
├── third-party-lib (已停止维护)
└── internal-framework (团队自研框架)
```

#### 4. 技术债务重
- 过时的设计模式
- 不一致的代码风格
- 历史遗留的临时解决方案
- 没有测试覆盖

### AI遇到的问题

| 问题 | AI的表现 | 原因 |
|------|----------|------|
| **上下文不足** | 给出不符合项目实际的建议 | AI看不到完整的项目背景 |
| **理解偏差** | 误解业务逻辑 | 复杂的业务规则隐藏在代码细节中 |
| **建议不切实际** | 让你重写整个模块 | AI不知道改动的影响范围 |
| **遗漏边界情况** | 没考虑特殊场景 | 历史代码中有很多"特殊处理" |

## 💡 让AI理解老项目的策略

### 策略1：提供项目上下文

#### 创建项目概览文档

先为AI创建一个项目概览，让它快速了解项目全貌：

```markdown
# 项目概览文档（给AI看）

## 项目基本信息
- **项目名称**：电商平台订单管理系统
- **开发时间**：2015年至今
- **技术栈**：Python 2.7/3.6, Django 1.11, PostgreSQL, Redis
- **团队规模**：3-5人
- **代码规模**：约15万行

## 核心业务流程
1. 用户下单 → 2. 支付处理 → 3. 库存扣减 → 4. 物流发货 → 5. 售后处理

## 项目结构
```
project/
├── core/           # 核心业务逻辑（最复杂，最老）
├── api/            # API接口（较新）
├── utils/          # 工具函数（杂乱）
├── models/         # 数据模型
└── services/       # 业务服务层
```

## 已知的技术债务
- core/order.py 有3000行，需要重构
- 支付模块有历史遗留的安全问题
- 没有单元测试
- 日志系统不完善

## 重要约定
- 所有价格计算必须使用 PriceCalculator 类
- 库存操作必须使用 InventoryManager
- 不要直接修改数据库，使用 Repository 模式
```

**使用方法**：在询问AI时，先把这个概览贴给AI

```
提示词：
"这是我的项目概览：
[粘贴项目概览]

现在我要问一个问题..."
```

### 策略2：分阶段暴露代码

#### ❌ 错误做法：一次性贴大量代码

```
你：帮我看看这段代码
[粘贴了1000行的代码]

AI：我需要看更多上下文才能理解...
或者给出完全错误的建议
```

#### ✅ 正确做法：按需逐步暴露

**阶段1：先描述问题**

```
提示词：
"我有一个Django项目的订单处理函数，
功能是处理订单支付，但最近出现了
库存扣减不准确的问题。

这个问题可能涉及到：
1. 支付回调处理
2. 库存锁机制
3. 并发事务处理

在提供代码前，你能先告诉我：
一般这种问题可能出现在哪些地方？"
```

**阶段2：提供核心逻辑**

```
提示词：
"这是支付回调的核心处理逻辑（关键部分）：

def handle_payment_callback(payment_data):
    with transaction.atomic():
        order = Order.objects.select_for_update().get(
            id=payment_data['order_id']
        )

        if payment_data['status'] == 'success':
            # 关键：这里库存扣减可能有问题
            deduct_inventory(order)
            order.status = 'paid'
            order.save()

能看出问题吗？需要我提供 deduct_inventory 的实现吗？"
```

**阶段3：逐步深入**

```
提示词：
"这是 deduct_inventory 的实现：

def deduct_inventory(order):
    for item in order.items.all():
        inventory = Inventory.objects.get(
            product_id=item.product_id
        )
        # 这里的逻辑很复杂...
        if inventory.quantity >= item.quantity:
            inventory.quantity -= item.quantity
            inventory.save()
        else:
            raise OutOfStockError()

这个函数在并发情况下有什么问题？
如何改进？"
```

### 策略3：使用结构化提问

#### 提问模板1：理解代码

```
提示词模板：
"我有一段代码需要你帮我理解。

【项目背景】
{简述项目类型、技术栈、这段代码的作用}

【代码片段】
{提供100-200行关键代码}

【我的理解】
{说明你已经理解的部分}

【我的疑问】
{具体列出不清楚的地方}

请帮我：
1. 确认我的理解是否正确
2. 解释我不理解的部分
3. 指出可能存在的问题"
```

**实战示例**：

```
提示词：
"我有一段代码需要你帮我理解。

【项目背景】
这是一个Django电商项目，这段代码是
订单系统的价格计算模块。

【代码片段】
def calculate_order_total(order):
    base_price = sum(item.price * item.quantity
                     for item in order.items)

    discount = 0
    if order.user.vip_level == 'gold':
        discount = base_price * 0.2
    elif order.user.vip_level == 'silver':
        discount = base_price * 0.1

    # 特殊促销
    if has_promotion(order):
        discount += apply_promotion(order)

    # 运费计算
    shipping = calculate_shipping(order)

    return {
        'subtotal': base_price,
        'discount': discount,
        'shipping': shipping,
        'total': base_price - discount + shipping
    }

【我的理解】
1. 计算订单基础价格
2. 根据VIP等级给予折扣
3. 应用促销折扣
4. 计算运费
5. 返回价格明细

【我的疑问】
1. has_promotion 和 apply_promotion 在哪里定义？
2. 如果折扣超过商品价格会怎样？
3. 这个函数在并发调用时会有问题吗？

请帮我分析这些问题。"
```

#### 提问模板2：修改代码

```
提示词模板：
"我需要在老代码中添加功能。

【现有功能】
{描述当前代码做什么}

【新增需求】
{描述要添加的新功能}

【约束条件】
1. 不能改动数据库结构
2. 不能影响现有功能
3. 需要保持向后兼容
4. 性能不能下降

【相关代码】
{提供相关代码片段}

请提供：
1. 实现方案（考虑约束条件）
2. 需要注意的风险点
3. 测试建议"
```

**实战示例**：

```
提示词：
"我需要在老代码中添加功能。

【现有功能】
订单系统支持全额退款。

【新增需求】
需要支持部分退款，用户可以只退订单中的
某些商品。

【约束条件】
1. 不能改动数据库结构（项目太老，
   改动风险大）
2. 不能影响现有全额退款功能
3. 需要保持向后兼容
4. 库存回退逻辑必须准确

【相关代码】
def refund_order(order_id):
    with transaction.atomic():
        order = Order.objects.get(id=order_id)
        if order.status != 'paid':
            raise InvalidStatusError()

        # 全额退款
        refund_payment(order.payment)
        restore_inventory(order)
        order.status = 'refunded'
        order.save()

请提供实现方案。"
```

#### 提问模板3：调试问题

```
提示词模板：
"我遇到了一个Bug。

【问题描述】
{描述Bug的表现}

【环境信息】
- 语言/框架：{技术栈}
- 触发条件：{什么时候出现}
- 错误信息：{具体的错误}

【相关代码】
{提供你认为相关的代码}

【我尝试过的方法】
1. {尝试1}
2. {尝试2}

【项目特点】
{说明项目的特殊情况，如：
- 这是遗留代码，不敢大改
- 涉及核心业务，需要谨慎
- 没有测试，改动风险大}

请帮我：
1. 分析可能的原因
2. 提供安全的修复方案
3. 说明如何验证修复"
```

**实战示例**：

```
提示词：
"我遇到了一个Bug。

【问题描述】
订单偶尔会出现重复扣款的情况，
大约每天出现1-2次，无法稳定复现。

【环境信息】
- Python 3.6 + Django 1.11
- PostgreSQL 9.6
- Redis作为缓存
- 支付宝/微信支付

【触发条件】
- 用户支付成功后
- 支付回调处理时
- 高并发场景

【错误信息】
日志显示同一笔订单的支付回调被
处理了两次

【相关代码】
def payment_callback(request):
    order_id = request.POST['order_id']
    status = request.POST['status']

    if status == 'success':
        order = Order.objects.get(id=order_id)
        if order.status == 'pending':
            # 扣款逻辑
            charge_payment(order)
            order.status = 'paid'
            order.save()

【我尝试过的方法】
1. 添加了日志，发现确实是两次回调
2. 怀疑是支付平台重复发送
3. 尝试在代码中加锁，但不确定是否正确

【项目特点】
- 这是核心支付逻辑，非常重要
- 没有测试，不敢大改
- 代码很老，可能有些历史包袱

请帮我分析并提供安全的修复方案。"
```

### 策略4：限制AI的作用范围

在老项目中，要让AI在"安全区域"工作：

#### ✅ 适合让AI做的事

| 任务 | 安全性 | 原因 |
|------|--------|------|
| **代码解释** | ⭐⭐⭐⭐⭐ | 不修改代码，只增加理解 |
| **添加注释** | ⭐⭐⭐⭐⭐ | 纯粹增强可读性 |
| **生成测试** | ⭐⭐⭐⭐ | 新增文件，不影响老代码 |
| **重构小函数** | ⭐⭐⭐ | 改动范围可控 |
| **性能分析** | ⭐⭐⭐⭐⭐ | 只读不写 |
| **写工具脚本** | ⭐⭐⭐⭐⭐ | 独立脚本，风险低 |

#### ⚠️ 需要谨慎的任务

| 任务 | 风险点 | 建议 |
|------|--------|------|
| **修改核心逻辑** | 影响范围大 | 先理解后手动改 |
| **数据库迁移** | 不可逆 | 人工设计方案 |
| **重构大模块** | 级联影响 | 分步骤小步重构 |
| **性能优化** | 可能引入Bug | 先测试再优化 |

#### ❌ 不建议让AI做的事

```
不要让AI：
1. "帮我重构整个订单模块"
   → 风险太大，影响面太广

2. "优化所有数据库查询"
   → 可能遗漏边界情况

3. "修改数据库结构"
   → 需要深度理解业务和数据

4. "重写这个老框架"
   → 可能破坏现有功能
```

## 🎯 分阶段使用AI的方法

### 阶段1：理解阶段（只读）

**目标**：让AI帮你理解代码，不做任何修改

#### 实战案例：理解复杂的订单处理逻辑

```
任务：理解一个2000行的订单处理函数

步骤1：先让AI看整体结构
提示词：
"这是一个订单处理函数的框架，
能帮我分析它的执行流程吗？

def process_order(order):
    # 第1部分：验证（100行）
    validate_order(order)

    # 第2部分：价格计算（300行）
    price_info = calculate_price(order)

    # 第3部分：库存处理（500行）
    handle_inventory(order)

    # 第4部分：支付处理（400行）
    process_payment(order)

    # 第5部分：通知发送（200行）
    send_notifications(order)

    # 第6部分：后续处理（500行）
    post_process(order)

请分析：
1. 这个函数的主要流程是什么？
2. 每个部分可能包含什么逻辑？
3. 可能存在的问题有哪些？"

步骤2：逐部分深入理解
提示词：
"让我们深入理解 calculate_price 部分。
这是它的代码（200行）：

[提供代码]

请帮我：
1. 画出价格计算的流程图
2. 标注关键的业务规则
3. 指出可能的问题"

步骤3：验证理解
提示词：
"根据你的分析，我理解这段代码是这样工作的：
[描述你的理解]

我的理解正确吗？有没有遗漏？"
```

**产出**：
- ✅ 清晰的代码理解
- ✅ 详细的流程图
- ✅ 潜在问题清单
- ✅ 没有任何代码修改

### 阶段2：安全改进阶段（低风险）

**目标**：做安全、独立的改进

#### 实战案例：为老代码添加测试

```
任务：为一个没有测试的老函数添加单元测试

步骤1：分析函数行为
提示词：
"这是一个订单价格计算函数：
[提供函数代码]

我想为它写单元测试，请帮我：
1. 列出所有需要测试的场景
2. 识别边界条件
3. 设计测试用例"

AI回答：
需要测试的场景：
1. 正常计算
2. VIP折扣
3. 促销折扣
4. 运费计算
5. 免运费条件
6. 负数价格处理
7. 空订单处理
...

步骤2：生成测试代码
提示词：
"根据上面的分析，请生成pytest测试代码。
要求：
1. 使用 pytest fixture
2. 每个测试场景独立
3. 使用 mock 隔离外部依赖
4. 测试数据要真实"

步骤3：验证测试
- 运行测试
- 检查覆盖率
- 确保测试通过

产出：
✅ 完整的测试套件
✅ 80%+ 的代码覆盖率
✅ 未修改任何老代码
✅ 为后续重构提供安全网
```

#### 实战案例：提取工具函数

```
任务：从复杂代码中提取可复用的工具函数

原代码（重复的逻辑）：
def process_order(order):
    # ... 其他代码

    # 计算折扣（逻辑重复）
    if order.user.vip_level == 'gold':
        discount = order.total * 0.2
    elif order.user.vip_level == 'silver':
        discount = order.total * 0.1
    else:
        discount = 0

    # ... 其他代码

def process_refund(refund):
    # ... 其他代码

    # 计算退款（同样的逻辑）
    if refund.order.user.vip_level == 'gold':
        refund_amount = refund.order.total * 0.2
    # ...

提示词：
"我发现在多个地方有重复的VIP折扣计算逻辑。
代码如上。

请帮我：
1. 提取成一个独立的工具函数
2. 考虑各种边界情况
3. 添加详细注释
4. 提供使用示例

要求：
- 新函数放在 utils/discount.py
- 保持向后兼容
- 不改变原有逻辑"

AI生成：
# utils/discount.py（新文件）
def calculate_vip_discount(user, total_amount):
    \"\"\"
    计算VIP折扣

    Args:
        user: 用户对象，需要有 vip_level 属性
        total_amount: 总金额（decimal.Decimal）

    Returns:
        decimal.Decimal: 折扣金额

    折扣规则：
    - gold: 20% off
    - silver: 10% off
    - 其他: 无折扣

    Examples:
        >>> calculate_vip_discount(gold_user, Decimal('100'))
        Decimal('20.00')
    \"\"\"
    discount_rates = {
        'gold': Decimal('0.20'),
        'silver': Decimal('0.10'),
    }

    rate = discount_rates.get(user.vip_level, Decimal('0'))
    return total_amount * rate

# 然后逐步替换老代码中的重复逻辑
```

**产出**：
- ✅ 独立的工具函数
- ✅ 减少代码重复
- ✅ 提高可维护性
- ✅ 风险可控（逐步替换）

### 阶段3：谨慎修改阶段（中风险）

**目标**：在充分理解后，做小步修改

#### 实战案例：修复Bug

```
任务：修复订单重复扣款问题

准备：
1. 阶段1已理解代码
2. 阶段2已添加测试
3. 已经识别了Bug原因

步骤1：设计修复方案
提示词：
"基于前面的分析，订单重复扣款是因为
支付回调没有幂等性保护。

原代码：
def payment_callback(request):
    order_id = request.POST['order_id']
    order = Order.objects.get(id=order_id)

    if order.status == 'pending':  # ❌ 并发不安全
        charge_payment(order)
        order.status = 'paid'
        order.save()

我计划这样修复：
1. 使用数据库锁
2. 添加幂等性检查
3. 记录回调日志

请评估这个方案是否安全？
有没有遗漏的边界情况？"

AI回答：
方案基本可行，但要注意：
1. select_for_update() 要放在事务中
2. 要处理锁超时的情况
3. 需要记录所有回调尝试
4. 建议添加缓存锁作为双重保护

步骤2：实现修复
提示词：
"请帮我实现修复后的代码，
要求：
1. 使用 select_for_update()
2. 添加幂等性token验证
3. 完整的错误处理
4. 详细的日志记录
5. 保持向后兼容"

步骤3：测试验证
- 在测试环境验证
- 运行所有单元测试
- 进行并发测试
- 观察日志确认

步骤4：逐步上线
- 先灰度10%流量
- 监控错误率
- 确认无问题后全量
```

**产出**：
- ✅ Bug已修复
- ✅ 有测试保护
- ✅ 有完整日志
- ✅ 风险可控

### 阶段4：重构阶段（高风险，需谨慎）

**目标**：重构复杂的老代码

**前提条件**：
- ✅ 已充分理解代码
- ✅ 有完整的测试覆盖
- ✅ 有充裕的时间
- ✅ 得到团队认可

#### 实战案例：重构2000行的订单函数

```
任务：重构 process_order 函数（2000行 → 模块化）

准备：
1. 已在阶段1充分理解代码
2. 已在阶段2添加了完整测试
3. 制定了详细的重构计划

步骤1：拆分策略
提示词：
"我要重构这个2000行的订单处理函数。
经过分析，它包含6个主要部分。

我的重构计划：
1. 创建 OrderProcessor 类
2. 每个部分拆分成独立方法
3. 提取 Validator、Calculator、Handler 等类
4. 保持对外的接口不变

请评估这个计划，
并提供更详细的拆分建议。"

步骤2：小步重构
提示词：
"我们先重构第一部分：订单验证。

这是验证部分的代码（100行）：
[提供代码]

请帮我：
1. 提取成 OrderValidator 类
2. 拆分成多个验证方法
3. 保持所有验证逻辑不变
4. 添加完整的错误消息
5. 写好文档字符串"

AI生成：
class OrderValidator:
    \"\"\"订单验证器\"\"\"

    def __init__(self, order):
        self.order = order
        self.errors = []

    def validate(self):
        \"\"\"执行所有验证\"\"\"
        self._validate_basic_info()
        self._validate_items()
        self._validate_inventory()
        self._validate_payment()

        if self.errors:
            raise ValidationError(self.errors)

        return True

    def _validate_basic_info(self):
        \"\"\"验证基本信息\"\"\"
        if not self.order.user_id:
            self.errors.append("用户ID不能为空")
        # ...

步骤3：验证重构
- 运行所有测试
- 对比重构前后行为
- 性能测试

步骤4：继续重构其他部分
- 每次只重构一个部分
- 每次都要验证
- 随时可以回滚

步骤5：完成重构
- 更新文档
- 团队代码评审
- 更新测试
```

**产出**：
- ✅ 代码清晰可维护
- ✅ 测试全部通过
- ✅ 性能无下降
- ✅ 文档完整

## 🛡️ 最佳实践

### 1. 建立安全网

在修改老代码前，必须建立保护措施：

```python
# 步骤1：添加测试
# 使用AI生成测试用例

# 步骤2：添加日志
import logging

logger = logging.getLogger(__name__)

def payment_callback(request):
    logger.info(f"Payment callback: {request.POST}")

    try:
        # 原有逻辑
        pass
    except Exception as e:
        logger.exception("Payment callback failed")
        raise

# 步骤3：添加监控
from prometheus_client import Counter

payment_callback_counter = Counter(
    'payment_callback_total',
    'Total payment callbacks'
)

# 步骤4：添加功能开关
from django.conf import settings

def payment_callback(request):
    if settings.FEATURES.get('new_payment_logic', False):
        return new_payment_logic(request)
    else:
        return old_payment_logic(request)
```

### 2. 小步快跑

```python
# ❌ 不好：一次大改
def process_order(order):
    # 完全重写，500行改动
    pass

# ✅ 好：小步多次改进

# 第1次：只提取验证逻辑
class OrderValidator:
    def validate(self, order):
        pass

def process_order(order):
    validator = OrderValidator()
    validator.validate(order)
    # 其余保持不变

# 第2次：提取价格计算
class PriceCalculator:
    def calculate(self, order):
        pass

def process_order(order):
    validator = OrderValidator()
    validator.validate(order)

    calculator = PriceCalculator()
    price = calculator.calculate(order)
    # 其余保持不变

# 继续小步改进...
```

### 3. 文档先行

```markdown
## 改动日志

### 2025-01-15: 修复订单重复扣款

**问题**：支付回调并发时可能重复扣款

**解决方案**：
1. 添加 select_for_update() 数据库锁
2. 添加幂等性token验证
3. 记录所有回调尝试

**测试**：
- 添加了并发测试用例
- 测试环境验证通过
- 灰度10%流量观察中

**回滚方案**：通过feature flag可以立即回滚

**相关文件**：
- core/payment.py: modified
- tests/test_payment.py: added
- docs/changelog.md: modified
```

### 4. 渐进式改进

```python
# 第1个月：只理解，不改
- 用AI解释代码
- 画流程图
- 识别问题

# 第2个月：添加安全措施
- 添加测试
- 添加日志
- 添加监控

# 第3个月：小步改进
- 修复简单Bug
- 提取工具函数
- 改善代码可读性

# 第4个月：谨慎重构
- 重构小模块
- 有测试保护的情况下
- 逐步进行
```

### 5. 团队协作

```
与团队沟通：

1. 改动前
   - 说明要改什么
   - 为什么改
   - 风险评估

2. 使用AI的建议时
   - 让团队评审
   - 集体讨论方案
   - 达成共识再改

3. 改动后
   - 代码评审
   - 分享经验
   - 更新文档
```

## ⚠️ 常见陷阱和避免方法

### 陷阱1：盲目信任AI

```
❌ 错误做法：
你：帮我优化这个函数
AI：[提供代码]
你：直接复制粘贴上线
结果：引入Bug，导致事故

✅ 正确做法：
1. 让AI解释为什么要这样改
2. 理解每个改动的目的
3. 评估是否适合你的项目
4. 添加测试验证
5. Code Review
6. 测试环境验证
7. 灰度上线
```

### 陷阱2：一次改动太大

```
❌ 错误做法：
"帮我重构整个订单模块"
→ 10000行改动
→ 无法Review
→ 上线后出问题
→ 无法回滚

✅ 正确做法：
1. "帮我理解这个函数"
2. "帮我添加测试"
3. "帮我提取这个小函数"
4. 每次改动控制在100行内
5. 每次都能独立验证
```

### 陷阱3：忽略项目历史

```
❌ 错误做法：
AI：建议使用最新的框架特性
你：直接使用
结果：与老代码不兼容，引入新问题

✅ 正确做法：
告诉AI：
"这是一个老项目：
- Python 3.6（不能用3.8+的特性）
- Django 1.11（不能用2.0+的特性）
- 有很多历史包袱
- 需要保持兼容性

请在这个前提下提供建议。"
```

### 陷阱4：没有测试就改

```
❌ 错误做法：
直接修改核心业务逻辑
没有测试
上线后发现Bug

✅ 正确做法：
1. 先让AI分析代码
2. 让AI生成测试
3. 运行测试确保通过
4. 再开始修改
5. 修改后运行所有测试
```

### 陷阱5：忽略边界情况

```
❌ 错误做法：
AI：[提供主要逻辑的实现]
你：直接使用
结果：没考虑异常情况，出Bug

✅ 正确做法：
每次让AI提供代码时，要求：
1. 处理所有异常
2. 考虑边界条件
3. 添加必要的校验
4. 完整的错误处理

提示词：
"请提供完整实现，要求：
- 处理所有可能的异常
- 考虑边界条件
- 添加输入验证
- 完整的错误处理
- 详细的日志记录"
```

## 📊 实战案例汇总

### 案例1：理解并修复支付并发问题

```
背景：
老项目偶尔出现订单重复扣款

过程：
第1天：
- 让AI分析支付回调代码
- AI识别出并发问题
- 理解问题根源

第2天：
- 让AI生成测试用例
- 添加并发测试
- 确认可以复现问题

第3天：
- 让AI提供修复方案
- 讨论多种方案的优劣
- 选择最安全的方案

第4天：
- 让AI实现修复代码
- Code Review
- 测试环境验证

第5天：
- 灰度10%流量
- 监控指标
- 确认无问题

结果：
✅ Bug修复
✅ 添加了保护措施
✅ 有完整测试
✅ 风险可控
```

### 案例2：为老代码添加文档和测试

```
背景：
核心函数没有任何文档和测试

过程：
Week 1：
- 让AI逐个函数解释
- 整理成文档
- 识别函数用途

Week 2：
- 让AI生成测试用例
- 逐步添加测试
- 达到80%覆盖率

Week 3：
- 让AI改进注释
- 添加docstring
- 提取使用示例

结果：
✅ 完整的API文档
✅ 80%测试覆盖率
✅ 新人快速上手
```

### 案例3：重构复杂的价格计算逻辑

```
背景：
价格计算有500行，难以维护

过程：
准备阶段（1周）：
- 深入理解现有逻辑
- 添加完整测试
- 绘制流程图

重构阶段（3周）：
- Week 1: 提取验证逻辑
- Week 2: 提取计算逻辑
- Week 3: 优化和测试

每次重构：
1. 小步改动（<100行）
2. 运行测试
3. 性能对比
4. 提交代码

结果：
✅ 500行 → 模块化设计
✅ 所有测试通过
✅ 性能无下降
✅ 易于维护
```

## 🎯 总结

### 在老项目中使用AI的关键原则

1. **理解优先**：先让AI帮你理解，再考虑修改
2. **小步前进**：每次改动要小，可验证，可回滚
3. **建立保护**：测试、日志、监控一个都不能少
4. **充分沟通**：与团队讨论，集体决策
5. **渐进改进**：从低风险任务开始，逐步增加难度

### 推荐的工作流

```
理解阶段（2-4周）
├─ 让AI解释代码
├─ 绘制架构图
├─ 识别问题点
└─ 编写文档

安全改进阶段（4-8周）
├─ 添加测试
├─ 添加日志
├─ 添加监控
└─ 提取工具函数

谨慎修改阶段（持续）
├─ 修复简单Bug
├─ 小步重构
├─ 性能优化
└─ 功能增强
```

### AI在老项目中的价值

| 方面 | 传统方式 | AI辅助 | 提升 |
|------|----------|--------|------|
| **理解代码** | 1-2周 | 2-3天 | 3-5x |
| **添加测试** | 1周 | 1-2天 | 3-5x |
| **修复Bug** | 1-3天 | 半天-1天 | 2-3x |
| **小步重构** | 2-4小时 | 30分钟-1小时 | 2-4x |
| **添加文档** | 2-3天 | 半天-1天 | 2-4x |

## 📚 延伸阅读

- [代码审查与重构](./05-代码审查与重构.md) - 学习更多重构技巧
- [代码调试与优化](./03-代码调试与优化.md) - 深入了解调试方法
- [架构设计辅助](./06-架构设计辅助.md) - 理解系统架构

---

💡 **最后提醒**：在老项目中使用AI，**谨慎**是第一原则。让AI成为你的助手，而不是替代你的思考。充分理解、充分测试、小步前进，才能真正发挥AI的价值。
